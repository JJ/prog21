* Programming in the 21st century

** א - Principles
*** Do *real* tasks

Even if they are part of a larger thing. Do also things that are not
programm-y, like looking at ancient texts or theater or art. In fact,
probably art is the best thing you can do. 

*** Show *real* code

Code that actually does something useful. Maybe part of a larger thing.

*** Use *any* language

Don't restrict yourself to a single language that can't do everything
(not every language is Perl). Create examples for many languages.  

*** Acknowledge the Internet

The Internet is there. Use it for APIs, for storage, for *see
also*. Your book is not going to be the only source for syntax, and
it's always easy to look syntax up instead of browsing a book. 

Also *web first*. Web is the single most used environment in the world
of programming. Use it first. And *cloud first*. Cloud is where you
run programs in the 21s century. Use it.

Also: be available for questions. It's impossible to write everything
for everyone.

*** Empower the user

Don't try to overwhelm the user, empower her. Show she can do it, it's
not daunting, don't condescend, don't "This is so easy even you can do
it". Show stuff, step by step, without pre-assumptions on what the
user knows or does not know.

Everyone programs, and not everyone is a computer science major. So
try to empower them to create stuff using computers by clearly
explaining what everything is about and how to achieve things. 

Empower the user by giving real names to things. Nobody starting to
program know what's an algorithm, or even what is source code. 

*** There is no true paradigm

Everything shouldn't be procedural, or object oriented, or
concurrent. Everything should be all of them. And *functional*. If
there's a single true paradigm, it's *functional programming* 

*** Ecosystems are the single unit of learning

Not the language. Show the existence of ecosystems that go from build
tools through the community to IRC channels. Show how to look for them
when in a new language neighborhood, and how to tap them for fixing
problems, keep up to date in language and features. 
** α - Why

Why follow this new path of learning programming in a new way, instead
of sticking to the old adage of learn the easy things first, then
other things later? If you've been a programmer you probably have your
own bag of tricks to do this, but people arrive to somewhere that
needs programming by the millions every single day. So this book (or
whatever it eventually becomes) is written for them. 

*** Go full stack

... and full queue, and full log, and full datastore, and full
everything. Don't draw yourself into a nanopart of a microservice. 

*** Polyglot is the norm

Even if you have a single full-service language like JavaScript, you
will need to use other DSLs or data languages along the way. And
JavaScript will eventually change or disappear for something cooler.

*** Hit the ground running

Land into a new project and adapt to it fast. Make easier to change
careers.

*** Program everything

... And the kitchen sink too. With IoT, smartphones, in-game
scripting, there are few things you can't program, inside or outside
work. 

*** Get the job done

Find the toolchain that works the best for a particular project,
including multilingual projects (which are going to 

** ß - Motivation and audience

This is addressed to instructors who want to make people approach
programming in a new way, those people that actually want to do it,
and also single-language programmers, who, in the grand scheme of
things, are pretty much the same as no-language programmers. 

*** All languages do the same.

They also look the the same in some cases.

*** Languages have a finite lifespan.

Even if you are committed to a language for life, it also
changes. Even Perl5 becomes Perl6 and everything changes.

*** Learning is lifelong

So you get a head start if you know everything first.

** 0 - What

What can be programmed? Why do you need programming? Programs are
everywhere, and you can program

*** Applications.
*** Games
*** Office applications

From simple macros and formulas to more complicated *glue* scripts to
connect them or update them.

*** Toys

Programmable robots, but that's just one example.

*** Internet of things

Most of them don't offer a lot of possibilities, but some can do
pretty nifty stuff.

*** Interactivity

In user interfaces, in home improvement, even in
wearables. Programming, and doing it yourself, is everywhere. 
** 1 - Doing stuff to data

First approach to programming, and something you can do everywhere,
from a spreadsheet cell to the command line. 

*** Math

*** REPLs

Where to find them, what to do with them, how they help you do stuff.

*** Other places to run stuff

*** Regular expressions.

What? They are expression. And they are regular.

*** Unicode

How to deal with funny characters

*** Conversions and casts

Sometimes all you have is binary... 
*** Rules and logic
** 2 - Storing data

Mainly variables and things, but also some other important things like
persistency, describing data, things like that. 

*** Where I will be able to use my data

Scope rules and what to do with them. Also what to avoid. 

*** Describing storage

Scope, naming conventions, types, restrictions... you have to put some
thought before you even start to name a thing.

*** Structuring data

How to throw data together until they form... bigger data. 

*** Data in the wild

There are many data formats out there, from the simpler to the more
complete. CSV to JSON. Maybe XML too. You should know this stuff.

*** Data-bases

The best base for your data. Working with very simple databases
starting with sqlite. 

*** How files are stored

And how to store information in them. 

** 3 - The flow

How to do things step by step. And how to do everything at the same
time. And how to do it asynchronously. And all other possible ways of
doing things.

*** Sequences
*** Events
*** Repeating things
*** Breaking the sequence

** 4 - Functions and closures

Putting a bunch of lines inside keys and what it all means. 


*** Getting things in and out of it
*** State 
*** Infinite calls and how to get out of them. 

** 5 - Putting stuff together

How to use more than one file in a project, and how to deal with
projects with them. And obviously, how to work in a project

*** Source control management.
*** Project files
*** Visual languages
*** Comments
*** Documentation 
*** Modularization.
*** Module repos 

And the start of the ecosystem.

** 6 - Dealing with errors

How to make a program work.

*** Making yourself understood
*** When it stops running: interpreting error messages

** 7 - Talking to the world

It's about time we understand how to print something, although we have
already done it. Let's do it more seriously.

*** Using stuff from others out there: APIs
*** Environment and what a program inherits

It's always standard input and output, but not always you can use
it. An introduction to object models.

*** Filing and cabinets

*** Security is all around us

*** Connecting things to one another

Sockets and UDP and XMPP and other things you might think of.

** 8 - Classes and types

One paradigm at a time. With you: object oriented programming.

(since this was impromptu, no breakdown)

** 9 - Preparing to run 


Getting things ready to run. But first, run the tests!
*** Continuous integration
*** Compilers
*** Build tools
*** Transpilers, uglifiers and other things like that.

** 10 - Flying to the cloud

Deploying your program elsewhere so that it can actually do what it is
wont to do. The cloud is someone else's computer, but it's also where
you run things in the 21st century. 

*** Provisioning
*** Scaling
*** Deploying
*** Containers
*** Ancillary programs

Monitoring, running, stopping, all that.

*** Continuous delivery.





